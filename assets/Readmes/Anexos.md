Disponible en [Español](#anexos)

---

## Appendices

#### 0. What does the `bootstrap_oidc.sh` script do?
- Creates/validates the GitHub OIDC Provider (`token.actions.githubusercontent.com`).
- Creates an IAM Role with a trust policy that allows only your repository (in my case: `hsniama/infra-devops-aws`) to assume it from GitHub Actions.

    ![Role Created](./img/3.png)

- Creates a permissions policy (e.g., `gh-oidc-terraform-infra-devops-aws-policy`) with access to:
    - **S3** (Terraform backend).
    - **DynamoDB** (Terraform lock).
    - **ECR, VPC, EC2, ELB, EKS, IAM, Autoscaling, Logs, KMS** (infrastructure).

    ![Policy Created](./img/4.png)

- Attaches/Binds the policy to the role.

    ![Policy attached](./img/5.png)

### 1. Explanation of the `gh-oidc-terraform-infra-devops-aws` role

The `gh-oidc-terraform-infra-devops-aws` role is an IAM Role in our AWS account. It consists of two critical components:
- **Trust policy** → defines who can assume it. In our case:
    - Only the GitHub OIDC provider (`token.actions.githubusercontent.com`).
    - Only our repository (`hsniama/infra-devops-aws`) and specific branches (`main`, `test/*`, `pull_request`).
- **Permissions policy** (`gh-oidc-terraform-infra-devops-aws-policy`) → defines what it can do once assumed.
    - Create VPCs, EC2, EKS, S3, DynamoDB, etc. (everything Terraform requires).

**Who uses this role?**
We do NOT use it directly with the `terraformUser` (which is my IAM user). It is used by GitHub Actions when the pipeline runs.

**How does GitHub Actions use it?**
1. In our `terraform.yml` GitHub Actions workflow, the secret is configured:

```json
AWS_ROLE_TO_ASSUME: arn:aws:iam::035462351040:role/gh-oidc-terraform-infra-devops-aws
```
![Role in terraform.yml](./img/18)

2. GitHub generates an OIDC token when the pipeline runs.
3. AWS validates that token against the OIDC provider you created.
4. If the token matches your repository and allowed branch → AWS allows GitHub to assume the role.
5. Upon assuming the role, GitHub obtains temporary credentials (STS) with the policy's permissions.
6. Terraform, within the pipeline, uses these credentials to deploy infrastructure in AWS.

**Advantages of this model**
- **Security**: There is no need to store `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` in GitHub.
- **Temporality**: Credentials last for minutes; they are not permanent keys.
- **Fine-grained control**: Only your repository and specific branches can assume the role.

### 3. Explanation of the `terraform.yml` workflow 

This pipeline distinguishes between testing and production environments. PRs against `main` generate a change plan in prod, merges to `main` apply changes in prod, pushes to `dev/**` branches apply in test, and it can also be executed manually by selecting the environment.

**Job Flow**
The pipeline has two main jobs:

- **Job plan**
  - Always runs (PR, push, manual).
  - Determines the environment (prod or test) based on the branch/event.
  - Runs `terraform fmt`, `init`, `validate`, and `plan`.
  - Generates a `tfplan` file and logs that are uploaded as artifacts.

- **Job apply**
  - Only runs on push or `workflow_dispatch` (not on PR).
  - Downloads the plan generated by the previous job.
  - Executes `terraform apply` with that exact plan.
  - Displays key outputs (ECR, EKS, etc.).
  - Uploads logs as artifacts.

**Security and Authentication**
- Uses OIDC with GitHub Actions to assume an AWS role (`AWS_ROLE_TO_ASSUME`).
- Does not require storing Access Keys in GitHub.
- Credentials are temporary and secure.

**Execution Summary**
- **PR → main** → plan in prod (review).
- **Push → main** → plan + apply in prod (actual deployment).
- **Push → dev/** → plan + apply in test (testing environment).
- **Manual dispatch** → plan + apply in test or prod based on input.

### 4. Security

**Currently:**
- Public endpoint enabled (for testing only).
- Access controlled via IAM.
- OIDC for GitHub Actions (no static secrets).

**Recommended for Production:**
- Restrict `cluster_endpoint_public_access_cidrs`.
- Disable public endpoint.
- Use AWS Load Balancer Controller + ACM for HTTPS.

### 5. Differences compared to Azure Infrastructure

The following table shows how the main components are mapped:

| Azure             | AWS              |
|-------------------|------------------|
| AKS               | EKS              |
| ACR               | ECR              |
| VNet              | VPC              |
| Azure AD OIDC     | IAM OIDC         |
| Storage Account   | S3               |
| Blob Container    | S3 Key           |
| Azure Lock        | DynamoDB Lock    |

**Explanation:**

- **AKS ↔ EKS**: Managed Kubernetes in Azure vs. AWS.
- **ACR ↔ ECR**: Container registry for Docker images.
- **VNet ↔ VPC**: Virtual networks to isolate and control traffic.
- **Azure AD OIDC ↔ IAM OIDC**: Federated identity providers for authentication.
- **Storage Account ↔ S3**: Object storage.
- **Blob Container ↔ S3 Key**: Blob containers vs. objects within a bucket.
- **Azure Lock ↔ DynamoDB Lock**: Locking mechanisms to prevent conflicts in the Terraform state.

## Estimated Costs 
- **EKS Control Plane**: ~$0.10 per hour.
- **EC2 Nodes**: Minimum of 2 nodes, depending on the instance type: `BOTTLEROCKET_x86_64` *(not very economical)*.
- **ECR**: Low cost (storage per GB).
- **S3 + DynamoDB**: Minimal cost.

---

## Anexos

#### 0. ¿Qué hace el script `bootstrap_oidc.sh`?
- Crea/valida el OIDC Provider de GitHub (token.actions.githubusercontent.com).
- Crea un rol IAM con trust policy que permite solo a tu repo (en mi caso: hsniama/infra-devops-aws) asumirlo desde GitHub Actions.

    ![Rol Creado](./img/3.png)

- Crea una policy de permisos (ej. gh-oidc-terraform-infra-devops-aws-policy) con acceso a:
    - S3 (backend de Terraform).
    - DynamoDB (lock de Terraform).
    - ECR, VPC, EC2, ELB, EKS, IAM, Autoscaling, Logs, KMS (infraestructura).

    ![Policy Creada](./img/4.png)

- Adjunta/Enlaza la policy al rol.

    ![Policy attached](./img/5.png)

### 1. Explicación rol `gh-oidc-terraform-infra-devops-aws`

El rol `gh-oidc-terraform-infra-devops-aws`
Es un IAM Role en nuestra cuenta AWS.
Tiene dos cosas importantes:
- Trust policy → define quién puede asumirlo. En nuestro caso:
    - Solo el OIDC provider de GitHub (token.actions.githubusercontent.com).
    - Solo nuestro repo (hsniama/infra-devops-aws) y ramas específicas (main, test/*, pull_request).
- Permissions policy (`gh-oidc-terraform-infra-devops-aws-policy`) → define qué puede hacer una vez asumido.
    - Crear VPCs, EC2, EKS, S3, DynamoDB, etc. (todo lo que Terraform necesita).

**¿Quién usa este rol?**
NO lo usamos nostros directamente con el usuario `terraformUser` (en mi caso, este es mi usuario IAM). Lo usa GitHub Actions cuando corre el  pipeline.

**¿Cómo lo usa GitHub Actions?**
1. En nuestro workflow `terraform.yml` de GitHub Actions, se configura el secreto:

```json
AWS_ROLE_TO_ASSUME: arn:aws:iam::035462351040:role/gh-oidc-terraform-infra-devops-aws
```
  ![Rol en terraform.yml](./img/18).

2. GitHub genera un token OIDC cuando se ejecuta el pipeline.
3. AWS valida ese token contra el OIDC provider que creaste.
4. Si el token corresponde a tu repo y rama permitida → AWS deja que GitHub asuma el rol.
5. Al asumir el rol, GitHub obtiene credenciales temporales (STS) con los permisos de la policy.
6. Terraform, dentro del pipeline, usa esas credenciales para desplegar infraestructura en AWS.

**Ventajas de este modelo**
**Seguridad**: no se necesita guardar AWS_ACCESS_KEY_ID y AWS_SECRET_ACCESS_KEY en GitHub.
**Temporalidad**: las credenciales duran minutos, no son llaves permanentes.
**Control fino**: solo tu repo y ramas específicas pueden asumir el rol.

### 3. Explicación del workflow `terraform.yml` 

Este pipeline diferencia entre ambientes de prueba y producción. Los PR contra main generan un plan de cambios en prod, los merges a main aplican en prod, los pushes a ramas dev/** aplican en test, y también se puede ejecutar manualmente seleccionando el ambiente.

**Flujo de jobs**
El pipeline tiene dos jobs principales:

- Job plan
  - Se ejecuta siempre (PR, push, manual).
  - Determina el ambiente (prod o test) según la rama/evento.
  - Corre terraform fmt, init, validate, y plan.
  - Genera un archivo tfplan y logs que se suben como artifacts.

- Job apply
  - Solo corre en push o workflow_dispatch (no en PR).
  - Descarga el plan generado por el job anterior.
  - Ejecuta terraform apply con ese plan exacto.
  - Muestra outputs clave (ECR, EKS, etc.).
  - Sube logs como artifacts.

**Seguridad y autenticación**
- Usa OIDC con GitHub Actions para asumir un rol en AWS (AWS_ROLE_TO_ASSUME).
- No requiere guardar Access Keys en GitHub.
- Las credenciales son temporales y seguras.

**Resumen de ejecución**
- PR → main → plan en prod (revisión).
- Push → main → plan + apply en prod (despliegue real).
- Push → dev/ → plan + apply en test (entorno de pruebas).
- Manual dispatch → plan + apply en test o prod según input.

### 4. Seguridad

Actualmente:
- Endpoint público habilitado (solo para pruebas)
- Acceso controlado vía IAM
- OIDC para GitHub Actions (sin secrets estáticos)

En producción se recomienda:

- Restringir cluster_endpoint_public_access_cidrs
- Deshabilitar endpoint público
- Usar AWS Load Balancer Controller + ACM para HTTPS

### 5. Diferencias respecto a una Infraestructura Azure

La siguiente tabla muestra cómo se mapean los componentes principales:

| Azure             | AWS              |
|-------------------|------------------|
| AKS               | EKS              |
| ACR               | ECR              |
| VNet              | VPC              |
| Azure AD OIDC     | IAM OIDC         |
| Storage Account   | S3               |
| Blob Container    | S3 Key           |
| Azure Lock        | DynamoDB Lock    |

Explicación:

- **AKS ↔ EKS**: Kubernetes administrado en Azure vs. AWS.  
- **ACR ↔ ECR**: Registro de contenedores para imágenes Docker.  
- **VNet ↔ VPC**: Redes virtuales para aislar y controlar tráfico.  
- **Azure AD OIDC ↔ IAM OIDC**: Proveedores de identidad federada para autenticación.  
- **Storage Account ↔ S3**: Almacenamiento de objetos.  
- **Blob Container ↔ S3 Key**: Contenedores de blobs vs. objetos dentro de un bucket.  
- **Azure Lock ↔ DynamoDB Lock**: Mecanismos de bloqueo para evitar conflictos en el estado de Terraform.  

## Costos estimados 
- **EKS Control Plane**: ~$0.10 por hora
- **EC2 Nodes**: mínimo 2 nodos y dependen del tipo de instancia: `BOTTLEROCKET_x86_64` *(no tan económico)* 
- **ECR**: bajo costo (almacenamiento por GB)
- **S3 + DynamoDB**: mínimo costo